{
  "language": "Solidity",
  "sources": {
    "@uniswap/lib/contracts/libraries/Babylonian.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.4.0;\n\n// computes square roots using the babylonian method\n// https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method\nlibrary Babylonian {\n    // credit for this implementation goes to\n    // https://github.com/abdk-consulting/abdk-libraries-solidity/blob/master/ABDKMath64x64.sol#L687\n    function sqrt(uint256 x) internal pure returns (uint256) {\n        if (x == 0) return 0;\n        // this block is equivalent to r = uint256(1) << (BitMath.mostSignificantBit(x) / 2);\n        // however that code costs significantly more gas\n        uint256 xx = x;\n        uint256 r = 1;\n        if (xx >= 0x100000000000000000000000000000000) {\n            xx >>= 128;\n            r <<= 64;\n        }\n        if (xx >= 0x10000000000000000) {\n            xx >>= 64;\n            r <<= 32;\n        }\n        if (xx >= 0x100000000) {\n            xx >>= 32;\n            r <<= 16;\n        }\n        if (xx >= 0x10000) {\n            xx >>= 16;\n            r <<= 8;\n        }\n        if (xx >= 0x100) {\n            xx >>= 8;\n            r <<= 4;\n        }\n        if (xx >= 0x10) {\n            xx >>= 4;\n            r <<= 2;\n        }\n        if (xx >= 0x8) {\n            r <<= 1;\n        }\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1;\n        r = (r + x / r) >> 1; // Seven iterations should be enough\n        uint256 r1 = x / r;\n        return (r < r1 ? r : r1);\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.0;\n\nlibrary BitMath {\n    // returns the 0 indexed position of the most significant bit of the input x\n    // s.t. x >= 2**msb and x < 2**(msb+1)\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, 'BitMath::mostSignificantBit: zero');\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    // returns the 0 indexed position of the least significant bit of the input x\n    // s.t. (x & 2**lsb) != 0 and (x & (2**(lsb) - 1)) == 0)\n    // i.e. the bit at the index is set and the mask of all lower bits is 0\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0, 'BitMath::leastSignificantBit: zero');\n\n        r = 255;\n        if (x & uint128(-1) > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & uint64(-1) > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & uint32(-1) > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & uint16(-1) > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & uint8(-1) > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FixedPoint.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.4.0;\n\nimport './FullMath.sol';\nimport './Babylonian.sol';\nimport './BitMath.sol';\n\n// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))\nlibrary FixedPoint {\n    // range: [0, 2**112 - 1]\n    // resolution: 1 / 2**112\n    struct uq112x112 {\n        uint224 _x;\n    }\n\n    // range: [0, 2**144 - 1]\n    // resolution: 1 / 2**112\n    struct uq144x112 {\n        uint256 _x;\n    }\n\n    uint8 public constant RESOLUTION = 112;\n    uint256 public constant Q112 = 0x10000000000000000000000000000; // 2**112\n    uint256 private constant Q224 = 0x100000000000000000000000000000000000000000000000000000000; // 2**224\n    uint256 private constant LOWER_MASK = 0xffffffffffffffffffffffffffff; // decimal of UQ*x112 (lower 112 bits)\n\n    // encode a uint112 as a UQ112x112\n    function encode(uint112 x) internal pure returns (uq112x112 memory) {\n        return uq112x112(uint224(x) << RESOLUTION);\n    }\n\n    // encodes a uint144 as a UQ144x112\n    function encode144(uint144 x) internal pure returns (uq144x112 memory) {\n        return uq144x112(uint256(x) << RESOLUTION);\n    }\n\n    // decode a UQ112x112 into a uint112 by truncating after the radix point\n    function decode(uq112x112 memory self) internal pure returns (uint112) {\n        return uint112(self._x >> RESOLUTION);\n    }\n\n    // decode a UQ144x112 into a uint144 by truncating after the radix point\n    function decode144(uq144x112 memory self) internal pure returns (uint144) {\n        return uint144(self._x >> RESOLUTION);\n    }\n\n    // multiply a UQ112x112 by a uint, returning a UQ144x112\n    // reverts on overflow\n    function mul(uq112x112 memory self, uint256 y) internal pure returns (uq144x112 memory) {\n        uint256 z = 0;\n        require(y == 0 || (z = self._x * y) / y == self._x, 'FixedPoint::mul: overflow');\n        return uq144x112(z);\n    }\n\n    // multiply a UQ112x112 by an int and decode, returning an int\n    // reverts on overflow\n    function muli(uq112x112 memory self, int256 y) internal pure returns (int256) {\n        uint256 z = FullMath.mulDiv(self._x, uint256(y < 0 ? -y : y), Q112);\n        require(z < 2**255, 'FixedPoint::muli: overflow');\n        return y < 0 ? -int256(z) : int256(z);\n    }\n\n    // multiply a UQ112x112 by a UQ112x112, returning a UQ112x112\n    // lossy\n    function muluq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        if (self._x == 0 || other._x == 0) {\n            return uq112x112(0);\n        }\n        uint112 upper_self = uint112(self._x >> RESOLUTION); // * 2^0\n        uint112 lower_self = uint112(self._x & LOWER_MASK); // * 2^-112\n        uint112 upper_other = uint112(other._x >> RESOLUTION); // * 2^0\n        uint112 lower_other = uint112(other._x & LOWER_MASK); // * 2^-112\n\n        // partial products\n        uint224 upper = uint224(upper_self) * upper_other; // * 2^0\n        uint224 lower = uint224(lower_self) * lower_other; // * 2^-224\n        uint224 uppers_lowero = uint224(upper_self) * lower_other; // * 2^-112\n        uint224 uppero_lowers = uint224(upper_other) * lower_self; // * 2^-112\n\n        // so the bit shift does not overflow\n        require(upper <= uint112(-1), 'FixedPoint::muluq: upper overflow');\n\n        // this cannot exceed 256 bits, all values are 224 bits\n        uint256 sum = uint256(upper << RESOLUTION) + uppers_lowero + uppero_lowers + (lower >> RESOLUTION);\n\n        // so the cast does not overflow\n        require(sum <= uint224(-1), 'FixedPoint::muluq: sum overflow');\n\n        return uq112x112(uint224(sum));\n    }\n\n    // divide a UQ112x112 by a UQ112x112, returning a UQ112x112\n    function divuq(uq112x112 memory self, uq112x112 memory other) internal pure returns (uq112x112 memory) {\n        require(other._x > 0, 'FixedPoint::divuq: division by zero');\n        if (self._x == other._x) {\n            return uq112x112(uint224(Q112));\n        }\n        if (self._x <= uint144(-1)) {\n            uint256 value = (uint256(self._x) << RESOLUTION) / other._x;\n            require(value <= uint224(-1), 'FixedPoint::divuq: overflow');\n            return uq112x112(uint224(value));\n        }\n\n        uint256 result = FullMath.mulDiv(Q112, self._x, other._x);\n        require(result <= uint224(-1), 'FixedPoint::divuq: overflow');\n        return uq112x112(uint224(result));\n    }\n\n    // returns a UQ112x112 which represents the ratio of the numerator to the denominator\n    // can be lossy\n    function fraction(uint256 numerator, uint256 denominator) internal pure returns (uq112x112 memory) {\n        require(denominator > 0, 'FixedPoint::fraction: division by zero');\n        if (numerator == 0) return FixedPoint.uq112x112(0);\n\n        if (numerator <= uint144(-1)) {\n            uint256 result = (numerator << RESOLUTION) / denominator;\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        } else {\n            uint256 result = FullMath.mulDiv(numerator, Q112, denominator);\n            require(result <= uint224(-1), 'FixedPoint::fraction: overflow');\n            return uq112x112(uint224(result));\n        }\n    }\n\n    // take the reciprocal of a UQ112x112\n    // reverts on overflow\n    // lossy\n    function reciprocal(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        require(self._x != 0, 'FixedPoint::reciprocal: reciprocal of zero');\n        require(self._x != 1, 'FixedPoint::reciprocal: overflow');\n        return uq112x112(uint224(Q224 / self._x));\n    }\n\n    // square root of a UQ112x112\n    // lossy between 0/1 and 40 bits\n    function sqrt(uq112x112 memory self) internal pure returns (uq112x112 memory) {\n        if (self._x <= uint144(-1)) {\n            return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << 112)));\n        }\n\n        uint8 safeShiftBits = 255 - BitMath.mostSignificantBit(self._x);\n        safeShiftBits -= safeShiftBits % 2;\n        return uq112x112(uint224(Babylonian.sqrt(uint256(self._x) << safeShiftBits) << ((112 - safeShiftBits) / 2)));\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: CC-BY-4.0\npragma solidity >=0.4.0;\n\n// taken from https://medium.com/coinmonks/math-in-solidity-part-3-percents-and-proportions-4db014e080b1\n// license is CC-BY-4.0\nlibrary FullMath {\n    function fullMul(uint256 x, uint256 y) internal pure returns (uint256 l, uint256 h) {\n        uint256 mm = mulmod(x, y, uint256(-1));\n        l = x * y;\n        h = mm - l;\n        if (mm < l) h -= 1;\n    }\n\n    function fullDiv(\n        uint256 l,\n        uint256 h,\n        uint256 d\n    ) private pure returns (uint256) {\n        uint256 pow2 = d & -d;\n        d /= pow2;\n        l /= pow2;\n        l += h * ((-pow2) / pow2 + 1);\n        uint256 r = 1;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        r *= 2 - d * r;\n        return l * r;\n    }\n\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 d\n    ) internal pure returns (uint256) {\n        (uint256 l, uint256 h) = fullMul(x, y);\n\n        uint256 mm = mulmod(x, y, d);\n        if (mm > l) h -= 1;\n        l -= mm;\n\n        if (h == 0) return l / d;\n\n        require(h < d, 'FullMath: FULLDIV_OVERFLOW');\n        return fullDiv(l, h, d);\n    }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
    },
    "@v60swap/core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n  event PairCreated(\n    address indexed token0,\n    address indexed token1,\n    address pair,\n    uint\n  );\n\n  function feeTo() external view returns (address);\n\n  function feeToSetter() external view returns (address);\n\n  function getPair(\n    address tokenA,\n    address tokenB\n  ) external view returns (address pair);\n\n  function allPairs(uint) external view returns (address pair);\n\n  function allPairsLength() external view returns (uint);\n\n  function createPair(\n    address tokenA,\n    address tokenB\n  ) external returns (address pair);\n\n  function setFeeTo(address) external;\n\n  function setFeeToSetter(address) external;\n\n  function v60AddressRegistry() external returns (address);\n}\n"
    },
    "@v60swap/core/contracts/interfaces/IUniswapV2Pair.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/interfaces/IIIERC20.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IIIERC20 {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address owner) external view returns (uint);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n\n    function transfer(address to, uint value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint value\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IUniswapV2Migrator.sol": {
      "content": "pragma solidity =0.6.6;\n\ninterface IUniswapV2Migrator {\n    function migrate(\n        address token,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/interfaces/IUniswapV2Router02.sol": {
      "content": "pragma solidity >=0.6.2;\n\nimport './IUniswapV2Router01.sol';\n\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external returns (uint amountETH);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external;\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external payable;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external;\n\n  function v60AddressRegistry() external pure returns (address);\n}\n"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}\n"
    },
    "contracts/interfaces/V1/IUniswapV1Exchange.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV1Exchange {\n    function balanceOf(address owner) external view returns (uint);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n    function removeLiquidity(uint, uint, uint, uint) external returns (uint, uint);\n    function tokenToEthSwapInput(uint, uint, uint) external returns (uint);\n    function ethToTokenSwapInput(uint, uint) external payable returns (uint);\n}\n"
    },
    "contracts/interfaces/V1/IUniswapV1Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV1Factory {\n    function getExchange(address) external view returns (address);\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "pragma solidity =0.6.6;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMath {\n    function add(uint x, uint y) internal pure returns (uint z) {\n        require((z = x + y) >= x, 'ds-math-add-overflow');\n    }\n\n    function sub(uint x, uint y) internal pure returns (uint z) {\n        require((z = x - y) <= x, 'ds-math-sub-underflow');\n    }\n\n    function mul(uint x, uint y) internal pure returns (uint z) {\n        require(y == 0 || (z = x * y) / y == x, 'ds-math-mul-overflow');\n    }\n}\n"
    },
    "contracts/libraries/UniswapV2Library.sol": {
      "content": "pragma solidity =0.6.6;\n\nimport \"@v60swap/core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@v60swap/core/contracts/interfaces/IUniswapV2Factory.sol\";\n\nimport \"./SafeMath.sol\";\n\nlibrary UniswapV2Library {\n  using SafeMath for uint;\n\n  // returns sorted token addresses, used to handle return values from pairs sorted in this order\n  function sortTokens(\n    address tokenA,\n    address tokenB\n  ) internal pure returns (address token0, address token1) {\n    require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n    (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n    require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n  }\n\n  // calculates the CREATE2 address for a pair without making any external calls\n  function pairFor(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal view returns (address pair) {\n    (address token0, address token1) = sortTokens(tokenA, tokenB);\n    pair = IUniswapV2Factory(factory).getPair(token0, token1);\n  }\n\n  // fetches and sorts the reserves for a pair\n  function getReserves(\n    address factory,\n    address tokenA,\n    address tokenB\n  ) internal view returns (uint reserveA, uint reserveB) {\n    (address token0, ) = sortTokens(tokenA, tokenB);\n    (uint reserve0, uint reserve1, ) = IUniswapV2Pair(\n      pairFor(factory, tokenA, tokenB)\n    ).getReserves();\n\n    (reserveA, reserveB) = tokenA == token0\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n  }\n\n  // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n  function quote(\n    uint amountA,\n    uint reserveA,\n    uint reserveB\n  ) internal pure returns (uint amountB) {\n    require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n    require(\n      reserveA > 0 && reserveB > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    amountB = amountA.mul(reserveB) / reserveA;\n  }\n\n  // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n  function getAmountOut(\n    uint amountIn,\n    uint reserveIn,\n    uint reserveOut\n  ) internal pure returns (uint amountOut) {\n    require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    uint amountInWithFee = amountIn.mul(997);\n    uint numerator = amountInWithFee.mul(reserveOut);\n    uint denominator = reserveIn.mul(1000).add(amountInWithFee);\n    amountOut = numerator / denominator;\n  }\n\n  // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n  function getAmountIn(\n    uint amountOut,\n    uint reserveIn,\n    uint reserveOut\n  ) internal pure returns (uint amountIn) {\n    require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n    require(\n      reserveIn > 0 && reserveOut > 0,\n      \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n    );\n    uint numerator = reserveIn.mul(amountOut).mul(1000);\n    uint denominator = reserveOut.sub(amountOut).mul(997);\n    amountIn = (numerator / denominator).add(1);\n  }\n\n  // performs chained getAmountOut calculations on any number of pairs\n  function getAmountsOut(\n    address factory,\n    uint amountIn,\n    address[] memory path\n  ) internal view returns (uint[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint[](path.length);\n    amounts[0] = amountIn;\n    for (uint i; i < path.length - 1; i++) {\n      (uint reserveIn, uint reserveOut) = getReserves(\n        factory,\n        path[i],\n        path[i + 1]\n      );\n      amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n    }\n  }\n\n  // performs chained getAmountIn calculations on any number of pairs\n  function getAmountsIn(\n    address factory,\n    uint amountOut,\n    address[] memory path\n  ) internal view returns (uint[] memory amounts) {\n    require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n    amounts = new uint[](path.length);\n    amounts[amounts.length - 1] = amountOut;\n    for (uint i = path.length - 1; i > 0; i--) {\n      (uint reserveIn, uint reserveOut) = getReserves(\n        factory,\n        path[i - 1],\n        path[i]\n      );\n      amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n    }\n  }\n}\n"
    },
    "contracts/libraries/UniswapV2LiquidityMathLibrary.sol": {
      "content": "pragma solidity =0.6.6;\n\nimport \"@v60swap/core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@v60swap/core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/lib/contracts/libraries/Babylonian.sol\";\nimport \"@uniswap/lib/contracts/libraries/FullMath.sol\";\n\nimport \"./SafeMath.sol\";\nimport \"./UniswapV2Library.sol\";\n\n// library containing some math for dealing with the liquidity shares of a pair, e.g. computing their exact value\n// in terms of the underlying tokens\nlibrary UniswapV2LiquidityMathLibrary {\n  using SafeMath for uint256;\n\n  // computes the direction and magnitude of the profit-maximizing trade\n  function computeProfitMaximizingTrade(\n    uint256 truePriceTokenA,\n    uint256 truePriceTokenB,\n    uint256 reserveA,\n    uint256 reserveB\n  ) internal pure returns (bool aToB, uint256 amountIn) {\n    aToB =\n      FullMath.mulDiv(reserveA, truePriceTokenB, reserveB) < truePriceTokenA;\n\n    uint256 invariant = reserveA.mul(reserveB);\n\n    uint256 leftSide = Babylonian.sqrt(\n      FullMath.mulDiv(\n        invariant.mul(1000),\n        aToB ? truePriceTokenA : truePriceTokenB,\n        (aToB ? truePriceTokenB : truePriceTokenA).mul(997)\n      )\n    );\n    uint256 rightSide = (aToB ? reserveA.mul(1000) : reserveB.mul(1000)) / 997;\n\n    if (leftSide < rightSide) return (false, 0);\n\n    // compute the amount that must be sent to move the price to the profit-maximizing price\n    amountIn = leftSide.sub(rightSide);\n  }\n\n  // gets the reserves after an arbitrage moves the price to the profit-maximizing ratio given an externally observed true price\n  function getReservesAfterArbitrage(\n    address factory,\n    address tokenA,\n    address tokenB,\n    uint256 truePriceTokenA,\n    uint256 truePriceTokenB\n  ) internal view returns (uint256 reserveA, uint256 reserveB) {\n    // first get reserves before the swap\n    (reserveA, reserveB) = UniswapV2Library.getReserves(\n      factory,\n      tokenA,\n      tokenB\n    );\n\n    require(\n      reserveA > 0 && reserveB > 0,\n      \"UniswapV2ArbitrageLibrary: ZERO_PAIR_RESERVES\"\n    );\n\n    // then compute how much to swap to arb to the true price\n    (bool aToB, uint256 amountIn) = computeProfitMaximizingTrade(\n      truePriceTokenA,\n      truePriceTokenB,\n      reserveA,\n      reserveB\n    );\n\n    if (amountIn == 0) {\n      return (reserveA, reserveB);\n    }\n\n    // now affect the trade to the reserves\n    if (aToB) {\n      uint amountOut = UniswapV2Library.getAmountOut(\n        amountIn,\n        reserveA,\n        reserveB\n      );\n      reserveA += amountIn;\n      reserveB -= amountOut;\n    } else {\n      uint amountOut = UniswapV2Library.getAmountOut(\n        amountIn,\n        reserveB,\n        reserveA\n      );\n      reserveB += amountIn;\n      reserveA -= amountOut;\n    }\n  }\n\n  // computes liquidity value given all the parameters of the pair\n  function computeLiquidityValue(\n    uint256 reservesA,\n    uint256 reservesB,\n    uint256 totalSupply,\n    uint256 liquidityAmount,\n    bool feeOn,\n    uint kLast\n  ) internal pure returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n    if (feeOn && kLast > 0) {\n      uint rootK = Babylonian.sqrt(reservesA.mul(reservesB));\n      uint rootKLast = Babylonian.sqrt(kLast);\n      if (rootK > rootKLast) {\n        uint numerator1 = totalSupply;\n        uint numerator2 = rootK.sub(rootKLast);\n        uint denominator = rootK.mul(5).add(rootKLast);\n        uint feeLiquidity = FullMath.mulDiv(\n          numerator1,\n          numerator2,\n          denominator\n        );\n        totalSupply = totalSupply.add(feeLiquidity);\n      }\n    }\n    return (\n      reservesA.mul(liquidityAmount) / totalSupply,\n      reservesB.mul(liquidityAmount) / totalSupply\n    );\n  }\n\n  // get all current parameters from the pair and compute value of a liquidity amount\n  // **note this is subject to manipulation, e.g. sandwich attacks**. prefer passing a manipulation resistant price to\n  // #getLiquidityValueAfterArbitrageToPrice\n  function getLiquidityValue(\n    address factory,\n    address tokenA,\n    address tokenB,\n    uint256 liquidityAmount\n  ) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n    (uint256 reservesA, uint256 reservesB) = UniswapV2Library.getReserves(\n      factory,\n      tokenA,\n      tokenB\n    );\n    IUniswapV2Pair pair = IUniswapV2Pair(\n      UniswapV2Library.pairFor(factory, tokenA, tokenB)\n    );\n    bool feeOn = IUniswapV2Factory(factory).feeTo() != address(0);\n    uint kLast = feeOn ? pair.kLast() : 0;\n    uint totalSupply = pair.totalSupply();\n    return\n      computeLiquidityValue(\n        reservesA,\n        reservesB,\n        totalSupply,\n        liquidityAmount,\n        feeOn,\n        kLast\n      );\n  }\n\n  // given two tokens, tokenA and tokenB, and their \"true price\", i.e. the observed ratio of value of token A to token B,\n  // and a liquidity amount, returns the value of the liquidity in terms of tokenA and tokenB\n  function getLiquidityValueAfterArbitrageToPrice(\n    address factory,\n    address tokenA,\n    address tokenB,\n    uint256 truePriceTokenA,\n    uint256 truePriceTokenB,\n    uint256 liquidityAmount\n  ) internal view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n    bool feeOn = IUniswapV2Factory(factory).feeTo() != address(0);\n    IUniswapV2Pair pair = IUniswapV2Pair(\n      UniswapV2Library.pairFor(factory, tokenA, tokenB)\n    );\n    uint kLast = feeOn ? pair.kLast() : 0;\n    uint totalSupply = pair.totalSupply();\n\n    // this also checks that totalSupply > 0\n    require(\n      totalSupply >= liquidityAmount && liquidityAmount > 0,\n      \"ComputeLiquidityValue: LIQUIDITY_AMOUNT\"\n    );\n\n    (uint reservesA, uint reservesB) = getReservesAfterArbitrage(\n      factory,\n      tokenA,\n      tokenB,\n      truePriceTokenA,\n      truePriceTokenB\n    );\n\n    return\n      computeLiquidityValue(\n        reservesA,\n        reservesB,\n        totalSupply,\n        liquidityAmount,\n        feeOn,\n        kLast\n      );\n  }\n}\n"
    },
    "contracts/libraries/UniswapV2OracleLibrary.sol": {
      "content": "pragma solidity >=0.5.0;\n\nimport \"@v60swap/core/contracts/interfaces/IUniswapV2Pair.sol\";\nimport \"@uniswap/lib/contracts/libraries/FixedPoint.sol\";\n\n// library with helper methods for oracles that are concerned with computing average prices\nlibrary UniswapV2OracleLibrary {\n  using FixedPoint for *;\n\n  // helper function that returns the current block timestamp within the range of uint32, i.e. [0, 2**32 - 1]\n  function currentBlockTimestamp() internal view returns (uint32) {\n    return uint32(block.timestamp % 2 ** 32);\n  }\n\n  // produces the cumulative price using counterfactuals to save gas and avoid a call to sync.\n  function currentCumulativePrices(\n    address pair\n  )\n    internal\n    view\n    returns (\n      uint price0Cumulative,\n      uint price1Cumulative,\n      uint32 blockTimestamp\n    )\n  {\n    blockTimestamp = currentBlockTimestamp();\n    price0Cumulative = IUniswapV2Pair(pair).price0CumulativeLast();\n    price1Cumulative = IUniswapV2Pair(pair).price1CumulativeLast();\n\n    // if time has elapsed since the last update on the pair, mock the accumulated price values\n    (\n      uint112 reserve0,\n      uint112 reserve1,\n      uint32 blockTimestampLast\n    ) = IUniswapV2Pair(pair).getReserves();\n    if (blockTimestampLast != blockTimestamp) {\n      // subtraction overflow is desired\n      uint32 timeElapsed = blockTimestamp - blockTimestampLast;\n      // addition overflow is desired\n      // counterfactual\n      price0Cumulative +=\n        uint(FixedPoint.fraction(reserve1, reserve0)._x) *\n        timeElapsed;\n      // counterfactual\n      price1Cumulative +=\n        uint(FixedPoint.fraction(reserve0, reserve1)._x) *\n        timeElapsed;\n    }\n  }\n}\n"
    },
    "contracts/libraries/UV2Library.sol": {
      "content": "pragma solidity =0.6.6;\n\nimport \"./UniswapV2LiquidityMathLibrary.sol\";\n\ncontract UV2Library {\n  using SafeMath for uint256;\n\n  address public immutable factory;\n\n  constructor(address factory_) public {\n    factory = factory_;\n  }\n\n  // see UniswapV2LiquidityMathLibrary#getReservesAfterArbitrage\n  function getReservesAfterArbitrage(\n    address tokenA,\n    address tokenB,\n    uint256 truePriceTokenA,\n    uint256 truePriceTokenB\n  ) external view returns (uint256 reserveA, uint256 reserveB) {\n    return\n      UniswapV2LiquidityMathLibrary.getReservesAfterArbitrage(\n        factory,\n        tokenA,\n        tokenB,\n        truePriceTokenA,\n        truePriceTokenB\n      );\n  }\n\n  // see UniswapV2LiquidityMathLibrary#getLiquidityValue\n  function getLiquidityValue(\n    address tokenA,\n    address tokenB,\n    uint256 liquidityAmount\n  ) external view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n    return\n      UniswapV2LiquidityMathLibrary.getLiquidityValue(\n        factory,\n        tokenA,\n        tokenB,\n        liquidityAmount\n      );\n  }\n\n  // see UniswapV2LiquidityMathLibrary#getLiquidityValueAfterArbitrageToPrice\n  function getLiquidityValueAfterArbitrageToPrice(\n    address tokenA,\n    address tokenB,\n    uint256 truePriceTokenA,\n    uint256 truePriceTokenB,\n    uint256 liquidityAmount\n  ) external view returns (uint256 tokenAAmount, uint256 tokenBAmount) {\n    return\n      UniswapV2LiquidityMathLibrary.getLiquidityValueAfterArbitrageToPrice(\n        factory,\n        tokenA,\n        tokenB,\n        truePriceTokenA,\n        truePriceTokenB,\n        liquidityAmount\n      );\n  }\n\n  // test function to measure the gas cost of the above function\n  function getGasCostOfGetLiquidityValueAfterArbitrageToPrice(\n    address tokenA,\n    address tokenB,\n    uint256 truePriceTokenA,\n    uint256 truePriceTokenB,\n    uint256 liquidityAmount\n  ) external view returns (uint256) {\n    uint gasBefore = gasleft();\n    UniswapV2LiquidityMathLibrary.getLiquidityValueAfterArbitrageToPrice(\n      factory,\n      tokenA,\n      tokenB,\n      truePriceTokenA,\n      truePriceTokenB,\n      liquidityAmount\n    );\n    uint gasAfter = gasleft();\n    return gasBefore - gasAfter;\n  }\n}\n"
    },
    "contracts/test/DeflatingERC20.sol": {
      "content": "pragma solidity =0.6.6;\n\nimport '../libraries/SafeMath.sol';\n\ncontract DeflatingERC20 {\n    using SafeMath for uint;\n\n    string public constant name = 'Deflating Test Token';\n    string public constant symbol = 'DTT';\n    uint8 public constant decimals = 18;\n    uint  public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor(uint _totalSupply) public {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n        _mint(msg.sender, _totalSupply);\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        uint burnAmount = value / 100;\n        _burn(from, burnAmount);\n        uint transferAmount = value.sub(burnAmount);\n        balanceOf[from] = balanceOf[from].sub(transferAmount);\n        balanceOf[to] = balanceOf[to].add(transferAmount);\n        emit Transfer(from, to, transferAmount);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, 'EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/test/ERC20.sol": {
      "content": "pragma solidity =0.6.6;\n\nimport '../libraries/SafeMath.sol';\n\ncontract ERC20 {\n    using SafeMath for uint;\n\n    string public constant name = 'Test Token';\n    string public constant symbol = 'TT';\n    uint8 public constant decimals = 18;\n    uint  public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    bytes32 public DOMAIN_SEPARATOR;\n    // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;\n    mapping(address => uint) public nonces;\n\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    constructor(uint _totalSupply) public {\n        uint chainId;\n        assembly {\n            chainId := chainid()\n        }\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(name)),\n                keccak256(bytes('1')),\n                chainId,\n                address(this)\n            )\n        );\n        _mint(msg.sender, _totalSupply);\n    }\n\n    function _mint(address to, uint value) internal {\n        totalSupply = totalSupply.add(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(address(0), to, value);\n    }\n\n    function _burn(address from, uint value) internal {\n        balanceOf[from] = balanceOf[from].sub(value);\n        totalSupply = totalSupply.sub(value);\n        emit Transfer(from, address(0), value);\n    }\n\n    function _approve(address owner, address spender, uint value) private {\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function _transfer(address from, address to, uint value) private {\n        balanceOf[from] = balanceOf[from].sub(value);\n        balanceOf[to] = balanceOf[to].add(value);\n        emit Transfer(from, to, value);\n    }\n\n    function approve(address spender, uint value) external returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    function transfer(address to, uint value) external returns (bool) {\n        _transfer(msg.sender, to, value);\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint value) external returns (bool) {\n        if (allowance[from][msg.sender] != uint(-1)) {\n            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);\n        }\n        _transfer(from, to, value);\n        return true;\n    }\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        require(deadline >= block.timestamp, 'EXPIRED');\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                '\\x19\\x01',\n                DOMAIN_SEPARATOR,\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))\n            )\n        );\n        address recoveredAddress = ecrecover(digest, v, r, s);\n        require(recoveredAddress != address(0) && recoveredAddress == owner, 'INVALID_SIGNATURE');\n        _approve(owner, spender, value);\n    }\n}\n"
    },
    "contracts/test/RouterEventEmitter.sol": {
      "content": "pragma solidity =0.6.6;\n\nimport '../interfaces/IUniswapV2Router01.sol';\n\ncontract RouterEventEmitter {\n    event Amounts(uint[] amounts);\n\n    receive() external payable {}\n\n    function swapExactTokensForTokens(\n        address router,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n            IUniswapV2Router01(router).swapExactTokensForTokens.selector, amountIn, amountOutMin, path, to, deadline\n        ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapTokensForExactTokens(\n        address router,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n            IUniswapV2Router01(router).swapTokensForExactTokens.selector, amountOut, amountInMax, path, to, deadline\n        ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapExactETHForTokens(\n        address router,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n            IUniswapV2Router01(router).swapExactETHForTokens.selector, amountOutMin, path, to, deadline\n        ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapTokensForExactETH(\n        address router,\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n            IUniswapV2Router01(router).swapTokensForExactETH.selector, amountOut, amountInMax, path, to, deadline\n        ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapExactTokensForETH(\n        address router,\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n            IUniswapV2Router01(router).swapExactTokensForETH.selector, amountIn, amountOutMin, path, to, deadline\n        ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n\n    function swapETHForExactTokens(\n        address router,\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable {\n        (bool success, bytes memory returnData) = router.delegatecall(abi.encodeWithSelector(\n            IUniswapV2Router01(router).swapETHForExactTokens.selector, amountOut, path, to, deadline\n        ));\n        assert(success);\n        emit Amounts(abi.decode(returnData, (uint[])));\n    }\n}\n"
    },
    "contracts/UniswapV2Migrator.sol": {
      "content": "pragma solidity =0.6.6;\n\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\n\nimport \"./interfaces/IUniswapV2Migrator.sol\";\nimport \"./interfaces/V1/IUniswapV1Factory.sol\";\nimport \"./interfaces/V1/IUniswapV1Exchange.sol\";\nimport \"./interfaces/IUniswapV2Router01.sol\";\nimport \"./interfaces/IIIERC20.sol\";\n\ncontract UniswapV2Migrator is IUniswapV2Migrator {\n    IUniswapV1Factory immutable factoryV1;\n    IUniswapV2Router01 immutable router;\n\n    constructor(address _factoryV1, address _router) public {\n        factoryV1 = IUniswapV1Factory(_factoryV1);\n        router = IUniswapV2Router01(_router);\n    }\n\n    // needs to accept ETH from any v1 exchange and the router. ideally this could be enforced, as in the router,\n    // but it's not possible because it requires a call to the v1 factory, which takes too much gas\n    receive() external payable {}\n\n    function migrate(\n        address token,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external override {\n        IUniswapV1Exchange exchangeV1 = IUniswapV1Exchange(\n            factoryV1.getExchange(token)\n        );\n        uint liquidityV1 = exchangeV1.balanceOf(msg.sender);\n        require(\n            exchangeV1.transferFrom(msg.sender, address(this), liquidityV1),\n            \"TRANSFER_FROM_FAILED\"\n        );\n        (uint amountETHV1, uint amountTokenV1) = exchangeV1.removeLiquidity(\n            liquidityV1,\n            1,\n            1,\n            uint(-1)\n        );\n        TransferHelper.safeApprove(token, address(router), amountTokenV1);\n        (uint amountTokenV2, uint amountETHV2, ) = router.addLiquidityETH{\n            value: amountETHV1\n        }(token, amountTokenV1, amountTokenMin, amountETHMin, to, deadline);\n        if (amountTokenV1 > amountTokenV2) {\n            TransferHelper.safeApprove(token, address(router), 0); // be a good blockchain citizen, reset allowance to 0\n            TransferHelper.safeTransfer(\n                token,\n                msg.sender,\n                amountTokenV1 - amountTokenV2\n            );\n        } else if (amountETHV1 > amountETHV2) {\n            // addLiquidityETH guarantees that all of amountETHV1 or amountTokenV1 will be used, hence this else is safe\n            TransferHelper.safeTransferETH(\n                msg.sender,\n                amountETHV1 - amountETHV2\n            );\n        }\n    }\n}\n"
    },
    "contracts/UniswapV2Router02.sol": {
      "content": "pragma solidity =0.6.6;\n\nimport \"@v60swap/core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\n\nimport \"./interfaces/IUniswapV2Router02.sol\";\nimport \"./libraries/UniswapV2Library.sol\";\nimport \"./libraries/SafeMath.sol\";\nimport \"./interfaces/IIIERC20.sol\";\nimport \"./interfaces/IWETH.sol\";\n\ninterface IV60AddressRegistry {\n  function v60Factory() external returns (address);\n\n  function v60Router() external returns (address);\n\n  function isRektMeme(address) external returns (bool);\n\n  function isMemeFactoryValid(address) external returns (bool);\n\n  function addMeme(address) external;\n}\n\ncontract UniswapV2Router02 is IUniswapV2Router02 {\n  using SafeMath for uint;\n\n  address public immutable override factory;\n  address public immutable override WETH;\n  address public immutable override v60AddressRegistry;\n\n  modifier ensure(uint deadline) {\n    require(deadline >= block.timestamp, \"UniswapV2Router: EXPIRED\");\n    _;\n  }\n\n  constructor(\n    address _factory,\n    address _WETH,\n    address _v60AddressRegistry\n  ) public {\n    factory = _factory;\n    WETH = _WETH;\n    v60AddressRegistry = _v60AddressRegistry;\n  }\n\n  receive() external payable {\n    assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n  }\n\n  // **** ADD LIQUIDITY ****\n  function _addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin\n  ) internal virtual returns (uint amountA, uint amountB) {\n    // create the pair if it doesn't exist yet\n    if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {\n      IV60AddressRegistry addressRegistry = IV60AddressRegistry(\n        v60AddressRegistry\n      );\n      if (\n        addressRegistry.isRektMeme(tokenA) || addressRegistry.isRektMeme(tokenB)\n      ) {\n        if (tokenA == WETH || tokenB == WETH) {\n          require(\n            addressRegistry.isRektMeme(msg.sender),\n            \"V60 Addition: memePair creation is only by memes logic\"\n          );\n        }\n      }\n      IUniswapV2Factory(factory).createPair(tokenA, tokenB);\n    }\n\n    (uint reserveA, uint reserveB) = UniswapV2Library.getReserves(\n      factory,\n      tokenA,\n      tokenB\n    );\n\n    if (reserveA == 0 && reserveB == 0) {\n      (amountA, amountB) = (amountADesired, amountBDesired);\n    } else {\n      uint amountBOptimal = UniswapV2Library.quote(\n        amountADesired,\n        reserveA,\n        reserveB\n      );\n      if (amountBOptimal <= amountBDesired) {\n        require(\n          amountBOptimal >= amountBMin,\n          \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\"\n        );\n        (amountA, amountB) = (amountADesired, amountBOptimal);\n      } else {\n        uint amountAOptimal = UniswapV2Library.quote(\n          amountBDesired,\n          reserveB,\n          reserveA\n        );\n        assert(amountAOptimal <= amountADesired);\n        require(\n          amountAOptimal >= amountAMin,\n          \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\"\n        );\n        (amountA, amountB) = (amountAOptimal, amountBDesired);\n      }\n    }\n  }\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  )\n    external\n    virtual\n    override\n    ensure(deadline)\n    returns (uint amountA, uint amountB, uint liquidity)\n  {\n    (amountA, amountB) = _addLiquidity(\n      tokenA,\n      tokenB,\n      amountADesired,\n      amountBDesired,\n      amountAMin,\n      amountBMin\n    );\n\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n\n    TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);\n    TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);\n    liquidity = IUniswapV2Pair(pair).mint(to);\n  }\n\n  function addLiquidityETH(\n    address token,\n    uint amountTokenDesired,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    external\n    payable\n    virtual\n    override\n    ensure(deadline)\n    returns (uint amountToken, uint amountETH, uint liquidity)\n  {\n    (amountToken, amountETH) = _addLiquidity(\n      token,\n      WETH,\n      amountTokenDesired,\n      msg.value,\n      amountTokenMin,\n      amountETHMin\n    );\n    address pair = UniswapV2Library.pairFor(factory, token, WETH);\n    TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);\n    IWETH(WETH).deposit{value: amountETH}();\n    assert(IWETH(WETH).transfer(pair, amountETH));\n    liquidity = IUniswapV2Pair(pair).mint(to);\n    // refund dust eth, if any\n    if (msg.value > amountETH)\n      TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n  }\n\n  // **** REMOVE LIQUIDITY ****\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  )\n    public\n    virtual\n    override\n    ensure(deadline)\n    returns (uint amountA, uint amountB)\n  {\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair\n    (uint amount0, uint amount1) = IUniswapV2Pair(pair).burn(to);\n    (address token0, ) = UniswapV2Library.sortTokens(tokenA, tokenB);\n    (amountA, amountB) = tokenA == token0\n      ? (amount0, amount1)\n      : (amount1, amount0);\n    require(amountA >= amountAMin, \"UniswapV2Router: INSUFFICIENT_A_AMOUNT\");\n    require(amountB >= amountBMin, \"UniswapV2Router: INSUFFICIENT_B_AMOUNT\");\n  }\n\n  function removeLiquidityETH(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  )\n    public\n    virtual\n    override\n    ensure(deadline)\n    returns (uint amountToken, uint amountETH)\n  {\n    (amountToken, amountETH) = removeLiquidity(\n      token,\n      WETH,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      address(this),\n      deadline\n    );\n    TransferHelper.safeTransfer(token, to, amountToken);\n    IWETH(WETH).withdraw(amountETH);\n    TransferHelper.safeTransferETH(to, amountETH);\n  }\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual override returns (uint amountA, uint amountB) {\n    address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);\n    uint value = approveMax ? uint(-1) : liquidity;\n    IUniswapV2Pair(pair).permit(\n      msg.sender,\n      address(this),\n      value,\n      deadline,\n      v,\n      r,\n      s\n    );\n    (amountA, amountB) = removeLiquidity(\n      tokenA,\n      tokenB,\n      liquidity,\n      amountAMin,\n      amountBMin,\n      to,\n      deadline\n    );\n  }\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual override returns (uint amountToken, uint amountETH) {\n    address pair = UniswapV2Library.pairFor(factory, token, WETH);\n    uint value = approveMax ? uint(-1) : liquidity;\n    IUniswapV2Pair(pair).permit(\n      msg.sender,\n      address(this),\n      value,\n      deadline,\n      v,\n      r,\n      s\n    );\n    (amountToken, amountETH) = removeLiquidityETH(\n      token,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      to,\n      deadline\n    );\n  }\n\n  // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) public virtual override ensure(deadline) returns (uint amountETH) {\n    (, amountETH) = removeLiquidity(\n      token,\n      WETH,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      address(this),\n      deadline\n    );\n    TransferHelper.safeTransfer(\n      token,\n      to,\n      IIIERC20(token).balanceOf(address(this))\n    );\n    IWETH(WETH).withdraw(amountETH);\n    TransferHelper.safeTransferETH(to, amountETH);\n  }\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external virtual override returns (uint amountETH) {\n    address pair = UniswapV2Library.pairFor(factory, token, WETH);\n    uint value = approveMax ? uint(-1) : liquidity;\n    IUniswapV2Pair(pair).permit(\n      msg.sender,\n      address(this),\n      value,\n      deadline,\n      v,\n      r,\n      s\n    );\n    amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(\n      token,\n      liquidity,\n      amountTokenMin,\n      amountETHMin,\n      to,\n      deadline\n    );\n  }\n\n  // **** SWAP ****\n  // requires the initial amount to have already been sent to the first pair\n  function _swap(\n    uint[] memory amounts,\n    address[] memory path,\n    address _to\n  ) internal virtual {\n    for (uint i; i < path.length - 1; i++) {\n      (address input, address output) = (path[i], path[i + 1]);\n      (address token0, ) = UniswapV2Library.sortTokens(input, output);\n      uint amountOut = amounts[i + 1];\n      (uint amount0Out, uint amount1Out) = input == token0\n        ? (uint(0), amountOut)\n        : (amountOut, uint(0));\n      address to = i < path.length - 2\n        ? UniswapV2Library.pairFor(factory, output, path[i + 2])\n        : _to;\n      IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(\n        amount0Out,\n        amount1Out,\n        to,\n        new bytes(0)\n      );\n    }\n  }\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n    amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    require(\n      amounts[amounts.length - 1] >= amountOutMin,\n      \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n    TransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      UniswapV2Library.pairFor(factory, path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, to);\n  }\n\n  function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n    amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    require(\n      amounts[0] <= amountInMax,\n      \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\"\n    );\n    TransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      UniswapV2Library.pairFor(factory, path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, to);\n  }\n\n  function swapExactETHForTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    payable\n    virtual\n    override\n    ensure(deadline)\n    returns (uint[] memory amounts)\n  {\n    require(path[0] == WETH, \"UniswapV2Router: INVALID_PATH\");\n    amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);\n    require(\n      amounts[amounts.length - 1] >= amountOutMin,\n      \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n    IWETH(WETH).deposit{value: amounts[0]}();\n    assert(\n      IWETH(WETH).transfer(\n        UniswapV2Library.pairFor(factory, path[0], path[1]),\n        amounts[0]\n      )\n    );\n    _swap(amounts, path, to);\n  }\n\n  function swapTokensForExactETH(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n    require(path[path.length - 1] == WETH, \"UniswapV2Router: INVALID_PATH\");\n    amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    require(\n      amounts[0] <= amountInMax,\n      \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\"\n    );\n    TransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      UniswapV2Library.pairFor(factory, path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, address(this));\n    IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n    TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n  }\n\n  function swapExactTokensForETH(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n    require(path[path.length - 1] == WETH, \"UniswapV2Router: INVALID_PATH\");\n    amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);\n    require(\n      amounts[amounts.length - 1] >= amountOutMin,\n      \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n    TransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      UniswapV2Library.pairFor(factory, path[0], path[1]),\n      amounts[0]\n    );\n    _swap(amounts, path, address(this));\n    IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n    TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n  }\n\n  function swapETHForExactTokens(\n    uint amountOut,\n    address[] calldata path,\n    address to,\n    uint deadline\n  )\n    external\n    payable\n    virtual\n    override\n    ensure(deadline)\n    returns (uint[] memory amounts)\n  {\n    require(path[0] == WETH, \"UniswapV2Router: INVALID_PATH\");\n    amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);\n    require(amounts[0] <= msg.value, \"UniswapV2Router: EXCESSIVE_INPUT_AMOUNT\");\n    IWETH(WETH).deposit{value: amounts[0]}();\n    assert(\n      IWETH(WETH).transfer(\n        UniswapV2Library.pairFor(factory, path[0], path[1]),\n        amounts[0]\n      )\n    );\n    _swap(amounts, path, to);\n    // refund dust eth, if any\n    if (msg.value > amounts[0])\n      TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n  }\n\n  // **** SWAP (supporting fee-on-transfer tokens) ****\n  // requires the initial amount to have already been sent to the first pair\n  function _swapSupportingFeeOnTransferTokens(\n    address[] memory path,\n    address _to\n  ) internal virtual {\n    for (uint i; i < path.length - 1; i++) {\n      (address input, address output) = (path[i], path[i + 1]);\n      (address token0, ) = UniswapV2Library.sortTokens(input, output);\n      IUniswapV2Pair pair = IUniswapV2Pair(\n        UniswapV2Library.pairFor(factory, input, output)\n      );\n      uint amountInput;\n      uint amountOutput;\n      {\n        // scope to avoid stack too deep errors\n        (uint reserve0, uint reserve1, ) = pair.getReserves();\n        (uint reserveInput, uint reserveOutput) = input == token0\n          ? (reserve0, reserve1)\n          : (reserve1, reserve0);\n        amountInput = IIIERC20(input).balanceOf(address(pair)).sub(\n          reserveInput\n        );\n        amountOutput = UniswapV2Library.getAmountOut(\n          amountInput,\n          reserveInput,\n          reserveOutput\n        );\n      }\n      (uint amount0Out, uint amount1Out) = input == token0\n        ? (uint(0), amountOutput)\n        : (amountOutput, uint(0));\n      address to = i < path.length - 2\n        ? UniswapV2Library.pairFor(factory, output, path[i + 2])\n        : _to;\n      pair.swap(amount0Out, amount1Out, to, new bytes(0));\n    }\n  }\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external virtual override ensure(deadline) {\n    TransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      UniswapV2Library.pairFor(factory, path[0], path[1]),\n      amountIn\n    );\n    uint balanceBefore = IIIERC20(path[path.length - 1]).balanceOf(to);\n    _swapSupportingFeeOnTransferTokens(path, to);\n    require(\n      IIIERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >=\n        amountOutMin,\n      \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n  }\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external payable virtual override ensure(deadline) {\n    require(path[0] == WETH, \"UniswapV2Router: INVALID_PATH\");\n    uint amountIn = msg.value;\n    IWETH(WETH).deposit{value: amountIn}();\n    assert(\n      IWETH(WETH).transfer(\n        UniswapV2Library.pairFor(factory, path[0], path[1]),\n        amountIn\n      )\n    );\n    uint balanceBefore = IIIERC20(path[path.length - 1]).balanceOf(to);\n    _swapSupportingFeeOnTransferTokens(path, to);\n    require(\n      IIIERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >=\n        amountOutMin,\n      \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n  }\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external virtual override ensure(deadline) {\n    require(path[path.length - 1] == WETH, \"UniswapV2Router: INVALID_PATH\");\n    TransferHelper.safeTransferFrom(\n      path[0],\n      msg.sender,\n      UniswapV2Library.pairFor(factory, path[0], path[1]),\n      amountIn\n    );\n    _swapSupportingFeeOnTransferTokens(path, address(this));\n    uint amountOut = IIIERC20(WETH).balanceOf(address(this));\n    require(\n      amountOut >= amountOutMin,\n      \"UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT\"\n    );\n    IWETH(WETH).withdraw(amountOut);\n    TransferHelper.safeTransferETH(to, amountOut);\n  }\n\n  // **** LIBRARY FUNCTIONS ****\n  function quote(\n    uint amountA,\n    uint reserveA,\n    uint reserveB\n  ) public pure virtual override returns (uint amountB) {\n    return UniswapV2Library.quote(amountA, reserveA, reserveB);\n  }\n\n  function getAmountOut(\n    uint amountIn,\n    uint reserveIn,\n    uint reserveOut\n  ) public pure virtual override returns (uint amountOut) {\n    return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);\n  }\n\n  function getAmountIn(\n    uint amountOut,\n    uint reserveIn,\n    uint reserveOut\n  ) public pure virtual override returns (uint amountIn) {\n    return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);\n  }\n\n  function getAmountsOut(\n    uint amountIn,\n    address[] memory path\n  ) public view virtual override returns (uint[] memory amounts) {\n    return UniswapV2Library.getAmountsOut(factory, amountIn, path);\n  }\n\n  function getAmountsIn(\n    uint amountOut,\n    address[] memory path\n  ) public view virtual override returns (uint[] memory amounts) {\n    return UniswapV2Library.getAmountsIn(factory, amountOut, path);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
